Task1.Part1

1)  Log in to the system as root. 

```sudo -i```

![image](https://user-images.githubusercontent.com/58170246/129597844-bb3be019-1b75-43fc-9834-ac4bb4a1ea6f.png)


2) Use the ```passwd``` command to change the password. Examine the basic parameters of the command. What system file does it change *?


The ```passwd``` program changes the passwords of user accounts. Regular user can only change the password for his own account, the superuser can change the password any account. ```passwd``` also changes account information, or password expiration date.


Введемо ```passwd``` и введемо новий пароль (asdzse30)


![image](https://user-images.githubusercontent.com/58170246/133388776-7e1eae5b-95d7-4b17-8652-52ef54c1fe92.png)



ПАРАМЕТРИ команди passwd:

```-a, --all``` Цей параметр можна використовувати тільки разом з -S для виведення статусу всіх користувачів.

```-d, --delete``` Видалити пароль користувача.

```-e, --expire``` Негайно зробити пароль застарілим. В результаті це змусить користувача змінити пароль при наступному вході в систему.

```-h, --help``` Показати коротку довідку і закінчити роботу.

```-i, --inactive``` DAY Цей параметр використовується для блокування облікового запису після заданого числа днів після старіння пароля. Тобто, якщо пароль застарів і пройшло більше зазначених ДНІВ, то користувач більше не зможе використовувати дану обліковий запис.

```-k, --keep-tokens``` Зміна пароля слід виконувати тільки для прострочених токенов аутентифікації (паролів).

```-l, --lock``` Заблокувати зазначену обліковий запис. Цей параметр блокує обліковий запис змінюючи значення пароля на варіант, який не може бути шифрованих паролем. 

```-m, --mindays``` МІН_ДНІВ Задати мінімальну кількість днів між зміною пароля. Нульове значення цього поля вказує на те, що користувач може змінювати свій пароль коли захоче.

```-q, --quiet``` Чи не виводити повідомлень при роботі.

```-r, --repository``` репозиторій


Змінити пароль репозиторію.

``-S, --status`` Показати стан облікового запису. Інформація про стан містить 7 полів. Перше поле містить ім'я облікового запису. Друге поле вказує, заблокована обліковий запис (L), вона без пароля (NP) або у неї є робочий пароль (P). Третє поле зберігає дату останньої зміни пароля. У наступних чотирьох полях зберігаються мінімальний термін, максимальний термін, період видачі попередження і період неактивності пароля. Ці терміни вимірюються в днях.

``-u, --unlock`` Розблокувати зазначену обліковий запис. Цей параметр активує обліковий запис змінюючи пароль на колишнє значення (яке було перед використанням параметра -l).

``-w, --warndays`` ПРЕД_ДНЕЙ Встановити число днів видачі попередження, перед тим як буде потрібно зміна пароля. У параметрі ПРЕД_ДНЕЙ вказується число днів перед тим як пароль застаріє, в перебігу яких користувачеві будуть нагадувати, що пароль скоро застаріє.

``-x, --maxdays МАКС_ДНІВ`` Встановити максимальну кількість днів, протягом яких пароль залишається робочим. Після МАКС_ДНЕЙ пароль потрібно змінити


3)  Determine the users registered in the system, as well as what commands they execute. What additional information can be gleaned from the command execution?


```passwd (etc / passwd)``` - містить інформацію про користувачів, мають такий вигляд запису - "user_name: password: UID: GID: full_name: home_directory: login_shell". Елементи запису повинні розділятися символом - ":" (двокрапка) і записуються без пробілів. Якщо пароль зберігається в зашифрованому вигляді у файлі / etc / shadow, то замість пароля вказується - "x".

список користувачів ```cat /etc/passwd```

![image](https://user-images.githubusercontent.com/58170246/133389363-d20e64de-0844-44e6-a598-f9eedd9eeca3.png)



4) Change personal information about yourself.


Подивимося інформацію про користувача: ```finger -l```

![image](https://user-images.githubusercontent.com/58170246/133389728-0c445589-c2b2-435e-aa74-d5c40e4486dd.png)
 
 бачимо що вона не інстальована
  
  інсталюємо її
  
  ```apt instal finger```
  
  ![image](https://user-images.githubusercontent.com/58170246/133390052-7c61f539-5d0c-4b76-80c1-5a740e4e187d.png)
  
  
  введемо знову ```finger -l```
  
  
  ![image](https://user-images.githubusercontent.com/58170246/133390186-ea361ed6-cc4c-4462-a029-d622522c2b39.png)


 

```chfn```

![image](https://user-images.githubusercontent.com/58170246/133412122-fc69f113-49eb-4d5a-a833-57fb9a1995d2.png)


Додамо інформацію про користувача:

Повне ім'я: !!!

Номер кімнати:!!!

Номер телефону: !!!

Інша: Student of the Epam !!!




Подивимося результати:


```less / etc / passwd```

![image](https://user-images.githubusercontent.com/58170246/133412369-0365474c-d4ba-4f53-8547-a30af787ba75.png)




5) Become familiar with the Linux help system and the man and info commands. Get help on the previously discussed commands, define and describe any two keys for these commands. Give examples.

Команда man виводить сторінку керівництва для зазначеного імені на стандартний висновок.
```$ man [назва команди]```

Кожна сторінка керівництва має стандартну форму з наступними розділами:


```NAME``` - назва і призначення

```SYNOPSIS``` - синтаксис

```DESCRIPTIONS``` - опис

```FILE``` - використовувані файли

```SEE ALSO``` - суміжні розділи

```DIAGNOSTIC``` - діагностика помилок

```BUGS``` - помічені помилки


Переглянемо інформацію про команду   ```passwd```
```man passwd```

![image](https://user-images.githubusercontent.com/58170246/133412592-3249a9c7-6c49-4eb8-a508-4117fd0f7a2a.png)


Для отримання інформації по окремій команді треба задати в командному рядку ```info``` з параметром, що є ім'ям, що цікавить нас команди, наприклад,

```$ info man```

![image](https://user-images.githubusercontent.com/58170246/133412731-92e39f19-f9a1-472e-ada2-7d2677c42761.png)


Істотна відмінність від команди man полягає в тому, що видається info інформація представлена в гіпертекстовому форматі. В силу цього ви отримуєте можливість переглядати різні розділи допомоги, не виходячи з оболонки, що надається командою ```info```.


6) Explore the more and less commands using the help system. View the contents of files .bash* using commands.

Команда ```more``` стара і основна термінальна команда, яка використовується при відкритті файлу для інтерактивного читання. Якщо вміст файлу занадто велике, щоб поміщатися на одному екрані, воно відображає вміст сторінки за сторінкою. Ви можете прокручувати вміст файлу, натискаючи клавіші ENTER або SPACE. Але одне обмеження - ви можете прокручувати тільки вперед, а не назад. Це означає, що ви можете прокручувати вниз, але не можете піднятися.

Відкриємо за допомогою цієї команди файл EpamTask.txt

![image](https://user-images.githubusercontent.com/58170246/133412839-47c3a647-cb78-4b9e-aa11-e8a7e14a552c.png)

7) * Describe in plans that you are working on laboratory work 1. Tip: You should read the documentation for the finger command.

```$echo "I am working on Lab 1" > ~/.plan```


![image](https://user-images.githubusercontent.com/58170246/133414870-306134d1-c2c3-489d-a342-9ef96b9ad0ba.png)



![image](https://user-images.githubusercontent.com/58170246/133414676-da065662-da60-45c1-af94-eec8fb49b5d7.png)




8) * List the contents of the home directory using the ls command, define its files and directories. Hint: Use the help system to familiarize yourself with the ls command.

Структура команди:

$ ls опції/шлях/до/папки

Основні опції утиліти:


-a - відображати всі файли, включаючи приховані, це ті, перед ім'ям яких стоїть крапка;

-A - не відображати посилання на поточну папку і кореневу папку. і ..;

--author - виводити творця файлу в режимі докладного списку;

-b - виводити Escape послідовності замість недрукованих символів;

--block-size - виводити розмір каталогу або файлу в певній одиниці виміру, наприклад, мегабайтах, гігабайтах або кілобайтах;

-B - не виводити резервні копії, їх імена починаються з ~;

-c - сортувати файли за часом модифікації або створення, спочатку будуть виведені нові файли;

-C - виводити колонками;

--color - включити кольоровий режим виведення, автоматично активована в багатьох дистрибутивах;

-d - виводити тільки директорії, без їх вмісту, корисно при рекурсивном виведення;

-D - використовувати режим виведення, сумісний з Emacs;

-f - НЕ сортувати;

-F - показувати тип об'єкта, до кожного об'єкта буде додано один із спеціалізованих символів * / => @ |;

--full-time - показувати детальну інформацію, плюс вся інформація про час в форматі ISO;

-g - показувати детальну інформацію, але крім власника файлу;

--group-directories-first - спочатку відображати директорії, а вже потім файли;

-G - не виводити імена груп;

-h - виводити розміри папок в зручному для читання форматі;

-H - відкривати символічні посилання при рекурсивном використанні;

--hide - не відображати файли, які починаються з вказаного символу;

-i - відображати номер індексу inode, в якій зберігається цей файл;

-l - виводити докладний список, в якому буде відображатися власник, група, дата створення, розмір та інші параметри;

-L - для символічних посилань відображати інформацію про фото, на який вони посилаються;

-m - розділяти елементи списку коми;

-n - виводити UID і GID замість імені і групи користувача;

-N - виводити імена як є, не обробляти контролюючі послідовності;

-Q - брати імена папок і файлів в лапки;

-r - зворотний порядок сортування;

-R - рекурсивно відображати вміст піддиректорій;

-s - виводити розмір файлу в блоках;

-S - сортувати за розміром, спочатку великі;

-t - сортувати за часом останньої модифікації;

-u - сортувати за часом останнього доступу;

-U - НЕ сортувати;

-X - сортувати за алфавітом;

-Z - відображати інформацію про розширення SELinux;

-1 - відображати один файл на один рядок.


Подивимося вміст домашнього каталогу:

``$ ls -l``


![image](https://user-images.githubusercontent.com/58170246/133415412-8121d35c-4992-42ea-909a-b43876ff292f.png)

![image](https://user-images.githubusercontent.com/58170246/133416043-dc582c60-05d5-414b-8f8d-59331164b948.png)



А тепер подивимося і з прихованими файлами:

``$ ls -а``

 ![image](https://user-images.githubusercontent.com/58170246/133415488-e25dbaf0-1540-436f-815d-3e4c03079925.png)
 
 ![image](https://user-images.githubusercontent.com/58170246/133415991-7a2a5590-7701-400e-ad6b-1f9ae8dd5b5c.png)


Task5.1.

Part2

1)Examine the tree command. Master the technique of applying a template, for example, display all files that contain a character c, or files that contain a specific sequence of characters. List subdirectories of the root directory up to and including the second nesting level. 

Команда ```tree``` вміє зображати структуру всіх каталогів, наявних на комп'ютері, у вигляді дерева. Його самі товсті гілки - це коренева папка і каталоги першого рівня вкладеності, а в ролі дрібних гілочок виступають окремі файли, які зберігаються десь далеко в надрах пам'яті.

```$ tree опції```

Опцій команди tree:


-a - виведення всіх без винятку файлів.

-d - тільки список директорій.

-l - перехід за символічними посиланнями, які ведуть до папок.

-f - вміст папок буде показано з префіксами шляху.

-x - враховує тільки поточну файлову систему.

-L - задає рівень вкладеності для відображення у висновку.

-R - рекурсивний перехід по каталогам всіх рівнів.

-P - відображення файлів, назва яких відповідає шаблону.

-I - виключення з виведення файлів, назва яких відповідає шаблону.

-o - друк виведення в файл з заданим ім'ям.

--noreport - забороняє команді виводити звіт по кількості папок і файлів в кінці дерева.

--charset - задає кодування для відображення графічних і html-файлів.

--filelimit - папки, які містять більше файлів, ніж вказано, показані не будуть.

А ці опції використовуються для управління відображенням назв документів:

-q - замінює недруковані символи в назвах файлів знаком?.

-N - виводить недруковані символи в назвах файлів як є.

-Q - укладає назви файлів в подвійні лапки.

-p - для кожного з файлів вказує його назва і список дозволених дій.

-u - друкує ім'я або ідентифікатор облікового запису, під якою був створений файл.

-g - друкує ім'я або ідентифікатор групи користувачів, яка має права на доступ до файлу.

-s - поруч з назвою файлу виводить його розмір в байтах.

-h - виводить розмір файлу в більш простому для людського сприйняття вигляді, додаючи до числа буквене скорочення.

-D - друкує дату внесення останніх змін (або остання зміна статусу в комбінації з опцією -c).

-F - додає символ / для папок, = для файлів сокета, * для виконуваних файлів,> для door-файлів, | для спеціальних файлів FIFO.

--inodes - виводить номера індексних дескрипторів для файлів і папок.

--device - вказує номер пристрою, до якого належить файл або папка.


Опції для сортування результатів:


-v - впорядковує видачу за рівнями вкладеності.

-t - сортує видачу за датою останньої зміни файлів і папок.

-c - сортує видачу за датою останньої зміни статусу.

-U - результати будуть виведені в тому порядку, в якому папки розташовані на диску.

-r - сортує видачу в зворотному порядку.

--dirsfirst - спочатку будуть показані папки, потім - файли.


Опції відображення дерева:


-i - прибирає лінії ( «гілки» дерева), файли і папки відображаються у вигляді списку.

-n - робить дерево одноколірним.

-C - повертає дереву різнобарвне відображення після використання опції -n.



Тепер відобразимо всі файли, що містять у своїй назві символ c

```tree -P "c" --prune```



А зараз відобразимо всі файли з розширенням txt.

```tree -P "* txt" --prune```



Тепер відобразимо підкаталоги кореневого каталогу до другого рівня вкладеності включно

```tree -L '2'```


2)What command can be used to determine the type of file (for example, text or binary)? Give an example.

У Linux є відмінна вбудована утиліта ```file```, яка визначає тип файлів і багато іншої інформації про файлах.

Припустимо у нас є файли без розширення і щоб подивитися інформацію про всіх файлах в поточній директорії виконаємо команду:

```file *```

Для конкретного файлу:

```file NAME```

Будь-який текстовий файл (відповідно до його евристикою) буде містити слово "text" в вихідних даних file; всі виконавчі файли не міститимуть слово "text".

Також для порівняння двох або кількох файлів в Linux є команда ```diff```. Вона може порівнювати як окремі файли, так і каталоги

Команда diff має наступний синтаксис:

```diff опції файл1 файл2```

Можна передати більше двох файлів, якщо це потрібно.

Опції утиліти:

-q - виводити тільки відмінності файлів;

-s - виводити тільки співпадаючі частини;

-с - виводити потрібну кількість рядків після збігів;

-u - виводити тільки потрібну кількість рядків після відмінностей;

-y - виводити в дві колонки;

-e - висновок в форматі ed скрипта;

-n - висновок в форматі RCS;

-a - порівнювати файли як текстові, навіть якщо вони не текстові;

-t - замінити табуляції на прогалини у висновку;

-l - розділити на сторінки і додати підтримку перегортання;

-r - рекурсивне порівняння папок;

-i - ігнорувати регістр;

-E - ігнорувати зміни в табуляції;

-Z - не враховувати прогалини в кінці рядка;

-b - не враховувати прогалини;

-B - не враховувати порожні рядки.

Це були основні опції утиліти, тепер давайте розглянемо як порівняти файли Linux. У висновку утиліти крім, безпосередньо, відображення змін, виводить рядок в якій вказується в який рядку і що було зроблено. Для цього використовуються такі символи:


a - додана;

d - видалена;

c - змінена.

Створимо два файли, напишемо в них щось і порівняємо.

В результаті ми отримали рядок: 2,3c2,4. Вона означає, що рядки 2 і 3 були змінені. І показані рядки, які відрізняються



3) Master the skills of navigating the file system using relative and absolute paths. How can you go back to your home directory from anywhere in the filesystem?


Переміщення по файлової системи можливо з використанням команди cd:

Абсолютний шлях вказує розташування каталогу по відношенню до кореневого каталогу. Кожен абсолютний шлях повинен починатися зі слеша (/).

Відносні шляхи визначають місце каталогу щодо поточного каталогу. Якщо каталог знаходиться близько до поточного каталогу в ієрархії, шлях буде простіше і коротше. На будь-який каталог в поточному каталозі можна посилатися на ім'я і без слеша (/).

Щоб повернутися в домашній каталог з будь-якої точки файлової системи досить написати:

```cd ~ cd /home/iryna```


4) Become familiar with the various options for the ls    command. Give examples of listing directories using different keys. Explain the information displayed on the terminal using the -l and -a switches.

Команда ls була розглянута в TASK 1.1 в пункті 8.


5) Perform the following sequence of operations: 


-  create a subdirectory in the home directory;

Найпростіший спосіб створити новий каталог - mkdir name. Наприклад створимо підкаталог з ім'ям "DevOps"


-  in this subdirectory create a file containing information about directories located in the root directory (using I/O redirection operations);

Створимо в підкаталозі DevOps файл LvivDevOps.txt, який буде містити інформацію про каталогах, розташованих в кореневому каталозі

touch DevOps/LvivDevOps.txt

Перейдемо в кореневій каталог:
cd ~

А тепер його вміст запишемо в файл LvivDevOps.txt.
ls -l> Desktop/DevOps/LvivDevOps.txt


-  view the created file;
cat Desktop/DevOps/LvivDevOps.txt


-  copy the created file to your home directory using relative and absolute addressing.

cp LvivDevOps.txt ~/LvivDevOps.txt

На скріншоті видно, що скопіювали файл в домашній каталог


-  delete the previously created subdirectory with the file requesting removal;


Щоб видалити порожню директорію використовуємо команду:
```rmdir Dir```

Але так як наша містить файл, то:

```rm -r ~/Desktop/DevOps```


-  delete the file copied to the home directory.

```rm LvivDevOps.txt```



6)Perform the following sequence of operations:

-  create a subdirectory testin the home directory;

```mkdir test```

-  copy the .bash_historyfile to this directory while changing its name to labwork2;

```cp .bash_history ~/test/labwork2```

-  create a hard and soft link to the labwork2file in the test subdirectory; 


Для створення символічних посилань існує утиліта ```ln```. Її синтаксис дуже простий:

```$ ln опції файл_джерела файл_посилання```

Опції утиліти:

-d - дозволити створювати жорсткі посилання для директорій суперкористувачеві;

-f - видаляти існуючі посилання;

-i - питати чи потрібно видаляти існуючі посилання;

-P - створити жорстке посилання;

-r - створити символічне посилання з відносним шляхом до файлу;

-s - створити символічне посилання.

Для створення м'якої посилання на наш файл labwork2 напишемо:

```ln -s labwork2 softlink```

Спробуємо подивитися вміст файлу за посиланням:

```cat softlink```



Немає ніякої різниці між посиланням і вихідним файлом. Але утиліта ```ls``` покаже що це дійсно посилання:

```ls -li```


Тепер створимо жорстке посилання на цей файл і протестимо його:

```ln labwork2 hardlink cat hardlink```




```$ ls -li```

-  how to define soft and hard link, what do theseconcepts;

СИМВОЛІЧНІ ПОСИЛАННЯ

Символічні посилання найбільше схожі на звичайні ярлики. Вони містять адресу потрібного файлу у вашій файловій системі. Коли ви намагаєтеся відкрити таку посилання, то відкривається цільової файл або папка. Головна її відмінність від жорстких посилань в тому, що при видаленні цільового файлу посилання залишиться, але вона буде вказувати в нікуди, оскільки файлу насправді більше немає.

Основні особливості символічних посилань:

-Можуть посилатися на файли і каталоги;

-Після видалення, переміщення або перейменування файлу стають недійсними;

-Права доступу і номер inode відрізняються від вихідного файлу;

-При зміні прав доступу для вихідного файлу, права на посилання залишаться незмінними;

-Можна посилатися на інші розділи диска;

-Содержат тільки ім'я файлу, а не його вміст.

-Тепер давайте розглянемо жорсткі посилання.

ЖОРСТКІ ПОСИЛАННЯ

Цей тип посилань реалізований на більш низькому рівні файлової системи. Файл розміщено тільки в певному місці жорсткого диска. Але на це місце можуть посилатися кілька посилань з файлової системи. Кожна з посилань - це окремий файл, але ведуть вони до одній ділянці жорсткого диска. Файл можна переміщати між каталогами, і всі посилання залишаться робочими, оскільки для них неважливо ім'я.

особливості:

-Працюють тільки в межах однієї файлової системи;

-Не можна посилатися на каталоги;

-Мають ту ж інформацію inode і набір дозволів що і у вихідного файлу;

-Дозвіл на посилання змінюватися при зміні дозволів файлу;

-Можна переміщати і перейменовувати і навіть видаляти файл без шкоди посиланням.


- change the data by opening a symbolic link. What changes will happen and why ;
- 

Відкрила файл через посилання, дописала до нього /// і зберегла.

```nano softlink```

Відкривши просто сам файл через cat я побачив, що теж додалася рядок ```///```.



-  rename the hard link file to hard_lnk_labwork2

```mv hardlink hard_lnk_labwork2```



-  rename the soft link file to symb_lnk_labwork2 file;

```mv softlink symb_lnk_labwork2```


-  then delete the labwork2. What changes have occurred and why?

Жорсткt посилання збереглося, а м'яке припинило працювати. Так як жорстке посилання linux це звичайний файл, тому він і існує незалежно від видалення вихідного файлу.

7) Using the locate utility, find all files that contain the squid and traceroute sequence.


Знайдемо всі файли, що містять послідовність squid

```locate "squid"```

Не знайдено жодного файлу

Тепер знайдемо всі файли, що містять послідовність traceroute.

```locate "traceroute"```



8) Determine which partitions are mounted in the system, as well as the types of these partitions.

Весь простір жорсткого диска поділенbq на розділи. Розділи не можуть перекриватися; простір, не виділенbq жодному розділу, називається вільним простором. Існує три типи розділів IDE-дисків: основний, логічний і розширений.


9) Count the number of lines containing a given sequence of characters in a given file.


Наприклад, порахуємо кількість рядків, що містять sudo в файлі .

```grep sudo * . | wc -l```

Відповідь: 

10) Using the findcommand, find all files in the /etc directory containing the host character sequence.

команда ```find```

Основні опцій команди ```find```.

-name Пошук файлів, імена яких відповідають заданим шаблоном

-print Запис повних імен знайдених файлів в стандартний потік виведення

-perm Пошук файлів, для яких встановлено зазначений режим доступу

-prune Застосовується для того, щоб команда find не виконувала рекурсивний пошук по вже знайденому подорожнього імені; якщо вказана опція -depth, опція -prune ігнорується

-user Пошук файлів, що належать зазначеному користувачеві

-group Пошук файлів, які належать даній групі

-mtime -n + n Пошук файлів, вміст яких модифікувався менш ніж (-) або більш ніж (+) n днів тому; є також опції -atime і -ctime, які дозволяють здійснювати пошук файлів відповідно за датою останнього читання і датою останнього зміни атрибутів файлу

-nogroup Пошук файлів, що належать неіснуючої групи, для якої, інакше кажучи, відсутній запис у файлі / etc / groups

-nouser Пошук файлів, що належать неіснуючому користувачеві, для якого, іншими словами, відсутній запис у файлі / etc / passwd

-newer файл Пошук файлів, які створені пізніше, ніж зазначений файл

-type Пошук файлів певного типу, а саме: b - спеціальний блоковий файл; d - каталог; з - спеціальний символьний файл; p - іменований канал; l - символічна посилання; s - сокет; f - звичайний файл

-size n Пошук файлів, розмір яких становить n одиниць; можливі наступні одиниці виміру: b- блок розміром 512 байт (установка за замовчуванням); з - байт; k - кілобайт (1024 байти); w - двухбайтовое слово

-depth При пошуку файлів спочатку проглядається вміст поточного каталогу і лише потім перевіряється запис, відповідна самому каталогу

-f stype Пошук файлів, які знаходяться в файлової системі певного типу; зазвичай відповідні відомості зберігаються в файлі / etc / fstab, який містить дані про файлових системах, використовуваних на локальному комп'ютері

-mount Пошук файлів тільки в поточній файлової системи; аналогом цієї опції є опція -xdev -exec Виконання команди інтерпретатора shell для всіх виявлених файлів; виконувані команди мають формат команда {};

Знайдемо всі файли в каталозі / etc, що містять послідовність символів S01:

```find / etc -name "S01 *" -print```



11) List all objects in /etc that contain the ss character sequence. How can I duplicate a similar command using a bunch of grep? 

```find / etc -name "ss" -print```

Якщо робити аналогічній процес використовуючи функцію grep, то потрібно написати:

```grep -r "ss" / etc```

Але все-одно висновок інформації буде відрізнятися, т.к grep больш сфокусована на пошуку інформації всередині файлу.


12) Organize a screen-by-screen print of the contents of the /etc directory. Hint: You must use stream redirection operations.


Запишемо вміст каталогу ```/etc``` в файл ```inf_etc.txt``` і розташуємо його в каталозі Downloads

ls -al /etc> Downloads/inf_etc.txt


13) What are the types of devices and how to determine the type of device? Give examples.

типи пристроїв

Файли пристроїв не є звичайними файлами: з ними не пов'язані блоки даних на диску. Дані, що поміщаються в такий файл або витягають із нього, передаються відповідному драйверу пристрою або приймаються від нього, а драйвер, в свою чергу, здійснює обмін даними з обслуговується пристроєм. Пристрої класифікуються за двома типами.

* Символьні (байт-орієнтовані) пристрої читають і записують дані у вигляді потоку байтів. Сюди входять послідовні і паралельні порти, накопичувачі на магнітній стрічці, термінали і звукові плати.

* Блокові (блок-орієнтовані) пристрої читають і записують дані блоками фіксованого розміру. На відміну від символьних пристроїв блокові пристрої надають довільний доступ до своїх даних. Як приклад можна назвати жорсткий диск.

Як правило, програми не працюють з блочними пристроями. У кожному розділі жорсткого диска міститься файлова система, яка монтується до дерева кореневої файлової системи Linux. Лише ядро, що реалізує функції файлової системи, отримує прямий доступ до блокового пристрою. Програми звертаються до вмісту диска через звичайні файли і каталоги.


14) How to determine the type of file in the system, what types of files are there?


Файли в операційній системі Linux можна поділити на три основні типи:

Звичайні файли, для зберігання інформації
Спеціальні файли - для пристроїв і тунелів
Директорії
Звичайні ФАЙЛИ

Це файли, з якими ми звикли працювати кожен день, вони можуть містити текст, виконувані інструкції для програм, зображення або іншу інформацію. Це найпоширеніший тип файлів, які ви можете знайти в системі Linux.

Невеликий список відносяться сюди файлів:

текстові файли
виконувані файли
файли зображень
файли архівів
Файли бібліотек програм
І інші подібні типи

Утиліта ls може визначати тип файлу в режимі списку, звичайні файли позначаються рискою, наприклад:

ls -l / bin / | grep "^ -"

СПЕЦІАЛЬНІ ФАЙЛИ

Спеціальні файли набагато цікавіше, вони призначені для обміну інформацією з ядром, роботи з пристроями або спілкування між програмами. Такі файли можуть теж бути декількох типів, в залежності від призначення.

Блокові файли - це файли пристроїв, які забезпечують буферізованние доступ до апаратних компонентів. При запису даних на жорсткий диск або на флешку немає сенсу записувати дані відразу ж після їх надходження. Так ми будемо тільки даремно витрачати ресурс пристрою і енергію. Можна почекати поки набереться достатня кількість даних а потім записати їх за один раз. Ці дані і збираються в буфері. За допомогою таких файлів, файлова система і багато інших програм можуть звертатися до драйверів апаратних пристроїв. Такі файли можуть передати великий блок даних за невеликої один раз.

Утиліта ls позначає блокові файли буквою b, наприклад, виберемо все блокові файли з каталогу / dev:
ls -l / dev / | grep "^ b"

Символьні файли забезпечують не буферізованние доступ до апаратних компонентів і ядру. Оскільки у них немає буфера, вони дозволяють передавати тільки по одному символу за один раз. А в іншому, це такі ж файли пристроїв, як і блокові файли.

Можна відфільтрувати їх за допомогою ls. Символьні файли позначаються літерою c (character):

ls -l / dev / | grep "^ c"

Символічні посилання - це файли, які вказують на інші файли в системі по їх імені. Вони можуть вказувати як на звичайні файли, таки на каталоги або інші типи файлів в linux. По суті, це ті ж ярлики Windows. У Linux ще є жорсткі посилання, але вони не мають відношення до типу файлів, тому що реалізовані на рівні файлової системи і вважаються звичайними файлами. Оскільки вони вказують на одне і те ж місце на диску, це два різних файлу, з однаковим вмістом.

Але повернемося до символічних посиланнях. Утиліта ls позначає їх буквою l (link):
ls -l / dev / | grep "^ l"

Файли сокетов - це файли, що забезпечують прямий зв'язок між процесами, вони можуть передавати інформацію між процесами, запущеними в різних середовищах або навіть різних машинах. Це означає, що за допомогою сокетів програми можуть обмінюватися даними навіть по мережі. По суті, сокет працює так само як тунелі, але тільки в обидві сторони.

Файли сокетов позначаються літерою s:

ls -l / dev / | grep "^ s"

КАТАЛОГИ

Це спеціальні файли, які дозволяють об'єднувати інші і каталоги в групи для більш простої навігації та пошуку. Природно, вони можуть містити як звичайні, так і спеціальні файли, одним словом будь-які типи файлів ос linux. В системі Linux, файли організовуються в папки починаючи від кореня (/)

Позначаються каталоги буквою d (directory):

15)* List the first 5 directory files that were recently accessed in the /etcdirectory. 
