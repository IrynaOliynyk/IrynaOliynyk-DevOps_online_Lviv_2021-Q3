TASK 5.3 

Part1

1. How many states could has a process in Linux?


Процес - це:

1) програма на стадії виконання

2) "об'єкт", яким виділено процесорний час

3) асинхронна робота

У Linux існують два основних типи процесів:

• Процеси переднього плану (Foreground) - ці процеси не започатковано і контролюються на протязі кінцевої сесії. Іншими словами, повинен бути користувач, підключений до системи для запуску таких процесів; вони не запускалися автоматично як частина функцій / служб системи.

• Фонові процеси (Background) (також належні до неінтерактивному / автоматичним процесам) - це процеси, не пов'язані з терміналом; вони не очікують від користувача введення.

На скріншоті нижче зображена модель п'яти станів

![image](https://user-images.githubusercontent.com/58170246/133625011-48651e0a-f061-4ede-8099-38053d06de84.png)


2. Examine the pstree command. Make output (highlight) the chain (ancestors) of the current process.

У простій формі, коли викликається ```pstree``` без будь-якої опції або аргументу, вона відображає ієрархічну деревоподібну структуру всіх запущених процесів:

![image](https://user-images.githubusercontent.com/58170246/133625496-650bd6f0-462f-4b06-b1ae-9530a5fde48a.png)


3. What is a proc file system?


Linux надає ядру і модулям ядра додатковий механізм передачі інформації зацікавленим в ній процесам - це файлова система /proc. Спочатку вона створювалася з метою отримання відомостей про процеси (звідси така назва). Тепер вона інтенсивно використовується і самим ядром, якому є що повідомити!

Наприклад, /proc/modules - список завантажених модулів, /proc/meminfo - статистика використання пам'яті.

Методика роботи з файловою системою / proc дуже схожа на роботу драйверів з файлами пристроїв: ви створюєте структуру з усією необхідною інформацією, включаючи покажчики на функції-обробники (в нашому випадку є тільки один обробник, який обслуговує читання файлу в / proc).

Файлова система / proc була написана, головним чином, для того щоб отримувати дані від ядра, вона не передбачає спеціальних засобів для запису даних в файли. Файлова система / proc, всякий раз, коли ми реєструємо новий файл, дозволяє вказати - яка struct inode_operations буде використовуватися для доступу до нього. У свою чергу, в цій структурі є покажчик struct file_operations, а в ній вже знаходяться покажчики на наші функції-обробники.

Наша файлова система показана на скрині нижче.


![image](https://user-images.githubusercontent.com/58170246/133625973-020822dd-a011-4307-a7ed-51b11b3f94b9.png)

https://losst.ru/fajlovaya-sistema-proc-v-linux

4. Print information about the processor (its type, supported technologies, etc.).

```cat /proc/cpuinfo```


![image](https://user-images.githubusercontent.com/58170246/133626280-8d1781f3-ee3b-4849-8c4a-c0e920c5342f.png)

5. Use the ps command to get information about the process. The information should be as follows: the owner of the process, the arguments with which the process was launched for execution, the group owner of this process, etc. 

Команда ```ps``` за замовчуванням є у всіх дистрибутивах Linux. Без будь-яких аргументів і опцій ps показує запущені процеси, що виконуються користувачем у вікні терміналу:

![image](https://user-images.githubusercontent.com/58170246/133626566-d2ae3786-b6c9-4fe8-8e6f-770ca5923558.png)


На виході будуть відображатися рядка даних, що містять наступну інформацію: * PID - це унікальний ідентифікатор процесу;

TTY - тип терміналу;

TIME - це загальний час використання процесорного часу процесом (00:00:00 навпаки процесу bash вказує, що процесорний час взагалі не було використано до сих пір);

CMD - це ім'я команди, яка запустила цей процес.

Щоб отримати повний список, виконаємо наступну команду:
```ps -ef```

Опція -e, показує всі процеси, а -f показує повну інформацію:

UID - ідентифікатор користувача виконує команду;

PID - це ідентифікатор процесу команди;

PPID - ідентифікатор батьківського процесу, який відпустив команду;

C - кількість дочірніх процесів;

STIME - це час початку процесу;

TTY;

TIME;

CMD.

```ps -ef```

![image](https://user-images.githubusercontent.com/58170246/133626758-c034117b-a934-400b-b341-82de6466f177.png)

```ps aux```

6. How to define kernel processes and user processes?


```ps aux```

![image](https://user-images.githubusercontent.com/58170246/133760630-bd6cfec2-aff9-4af2-a47c-bc8a56248dd2.png)



Некоторые процессы указаны в квадратных скобках [ ] – это процессы, которые входят непосредственно в состав ядра и выполняют важные системные задачи, например, такие как управление буферным кэшем [pdflush] и организацией свопинга [kswapd].

Остальная часть процессов относится к пользовательским.



7. Print the list of processes to the terminal. Briefly describe the statuses of the processes. What condition are they in, or can they be arriving in?


Посмотрим список процессов:

```ps aux```


![image](https://user-images.githubusercontent.com/58170246/133760921-b3d71265-ac2d-41af-a832-34f9be46e8ef.png)



У таблиці відображається різна інформація про процес. Нас зараз цікавлять колонки PID (ідентифікатор процесу), USER (користувач, який запустив процес), STAT (стан процесу) і COMMAND (команда, яка була введена для запуску процесу).

Колонка STAT (стан процесу) може містити такі значення:

R: процес виконується в даний момент

S: процес очікує (тобто спить менше 20 секунд)

I: процес не діє (тобто спить більше 20 секунд)

D: процес очікує введення-виведення (або іншого недовгого події), неперервні

Z: zombie або defunct процес, тобто завершився процес, код повернення якого поки не прочитано батьком

T: процес зупинений

W: процес в своп

<: Процес в пріоритетному режимі.

N: процес в режимі низького пріоритету

L: real-time процес, є сторінки, заблоковані в пам'яті.

s: лідер сесії
 

8. Display only the processes of a specific user. 

```ps -fu iryna```

![image](https://user-images.githubusercontent.com/58170246/133761124-ac49cf84-bde8-41e2-be74-01a3cdde46d5.png)


```ps -al -u iryna```

![image](https://user-images.githubusercontent.com/58170246/133761279-66c76f62-a2d9-405f-87a6-babf75a2292d.png)



9. What utilities can be used to analyze existing running tasks (by analyzing the help for the ps command)?

УТИЛІТИ:

```ps```

```top```

![image](https://user-images.githubusercontent.com/58170246/133762079-4408b57b-56c2-43d5-9fc1-883caa93aa20.png)


```sudo apt-get install htop```

![image](https://user-images.githubusercontent.com/58170246/133762588-aadd2837-8246-4c6b-b5e4-d425357d129e.png)



```htop```

![image](https://user-images.githubusercontent.com/58170246/133762693-411662ff-c50d-4906-80cf-73ad9fce73dc.png)


```sudo apt-get install atop```

![image](https://user-images.githubusercontent.com/58170246/133762922-c3866b5b-97cb-4d3e-a78b-88eb051c4503.png)


```atop```


![image](https://user-images.githubusercontent.com/58170246/133762989-549a4dcf-b0d9-404a-b963-c7256300eb69.png)




10. What information does ```top``` command display?

Основні опції:

-v - вивести версію програми;

-b - режим тільки для виведення даних, програма не сприймає інтерактивних команд і виконується поки не буде завершена вручну;

-c - відображати повний шлях до виконуваних файлів команд;

-d - інтервал оновлення інформації;

-H - включає висновок потоків процесів;

-i - не відображати процеси, які не використовують ресурси процесора;

-n - кількість циклів оновлення даних, після яких треба закрити програму;

-o - поле, по якому треба виконувати сортування;

-O - вивести всі доступні поля для сортування;

-p - відстежувати тільки зазначені по PID процеси, можна вказати кілька PID;

-u - виводити тільки процеси, запущені від імені зазначеного користувача.

```top```

![image](https://user-images.githubusercontent.com/58170246/133763114-d00d3de4-1ef4-4bab-b659-807bd7036cdb.png)



Вікно можна умовно розділити на дві частини. У верхній частині знаходиться інформація про систему, спільне використання ресурсів процесора і пам'яті, розділу підкачки, і так далі. У нижній частині вікна розташований список запущених процесів з інформацією, відсортованих за певним полю.

Якщо всі процеси не поміщаються на одному екрані, їх можна гортати за допомогою стрілок вгору і вниз. Якщо не поміщаються всі колонки - за допомогою стрілок вправо і вліво:

11.Display the processes of the specific user using the ```top``` command..

Відобразимо процеси користувача iryna:

top -u iryna

![image](https://user-images.githubusercontent.com/58170246/133763244-6ca90e1a-f548-430c-bd0b-1dba7f70b48d.png)


12. What interactive commands can be used to control the top command? Give a couple of examples.

Розглянемо інтерактивні команди, які можна виконувати під час роботи програми:

h - висновок довідки по утиліті;

q або Esc - вихід з top;

A - вибір колірної схеми;

d або s - змінити інтервал оновлення інформації;

H - виводити потоки процесів;

k - послати сигнал завершення процесу;

W - записати поточні настройки програми в конфігураційний файл;

Y - подивитися додаткові відомості про процес, відкриті файли, порти, логи і т. Д;

Z - змінити колірну схему;

l - приховати або вивести інформацію про середньому навантаженні на систему;

m - вимкнути або переключити режим відображення інформації про пам'ять;

x - виділяти жирним колонку, по якій виконується сортування;

y - виділяти жирним процеси, які виконуються в даний момент;

z - перемикання між кольоровим і одноколірним режимами;

c - перемикання режиму виведення команди, доступний повний шлях і тільки команда;

F - настройка полів з інформацією про процеси;

o - фільтрація процесів за довільним умові;

u - фільтрація процесів на ім'я користувача;

V - відображення процесів у вигляді дерева;

i - щоб переключатися між процесів, які зараз не використовують ресурси процесора;

n - максимальна кількість процесів, для відображення в програмі;

L - пошук по слову;

<> - переміщення поля сортування вправо і вліво;

13. Sort the contents of the processes window using various parameters (for example, the amount of processor time taken up, etc.)

Shift + M - сортування за використанням пам'яті

![image](https://user-images.githubusercontent.com/58170246/133763870-a6c5e424-96f5-4ece-a5bc-827f2a6c0a9d.png)

Shift + T - за робочим часом

![image](https://user-images.githubusercontent.com/58170246/133764039-5ae71461-a2c8-4db3-b997-c5928842d3da.png)

Shift + N - за PID

![image](https://user-images.githubusercontent.com/58170246/133764116-3b947583-5e59-4bb3-93fa-11589f9f7f1d.png)

14. Concept of priority, what commands are used to set priority?

Кожному процесу в системі призначений певний пріоритет, який враховується планувальником процесів при виділенні процесу процесорного часу. Значення пріоритету знаходиться в діапазоні від -20 (найвищий пріоритет) до 19 (найменший: процес виконується тільки тоді, коли немає інших претендентів на час процесора). Значення, зворотне пріоритету, називається показником поступливості (nice).

За замовчуванням всі процеси запускаються з базовим пріоритетом, рівним 0. Власник процесу може в будь-який момент підвищити його показник поступливості (знизити пріоритет). Суперкористувач має право встановити для будь-якого процесу будь-яке значення пріоритету.

Якщо процес від'їдає занадто багато ресурсів, то для нормального функціонування системи не обов'язково його вбивати: досить призначити йому низький пріоритет. Тоді планувальник надасть йому менше циклів процесора, і його виконання займе більше часу, зате протягом цього часу можна буде виконувати інші завдання.

Для запуску процесу з пріоритетом, відмінним від базового, служить команда nice:

```nice [-n <пріоритет>] [командна_стрічка]```

Щоб змінити пріоритет вже запущеного процесу служить команда renice:

```renice -n <показник_поступливості> [-p PID] [-u UID]```

![image](https://user-images.githubusercontent.com/58170246/133764716-8bc71bbe-2d10-47bc-9c00-7a59cb8c62ee.png)



15. Can I change the priority of a process using the top command? If so, how?

Можна використовувати команду ```r``` під час виконання утиліти top, щоб змінити пріоритет поточного запущеного процесу.

16. Examine the kill command. How to send with the kill commandprocess control signal? Give an example of commonly used signals.


Використання команди ```kill```  з /usr/bin надає додаткову можливість перервати процес по його імені за допомогою ```pkill```. Стандартний синтаксис команди kill наступний:

```kill [сигнал або опція] ідентифікатор(и) процесу(ів)```

Для команди kill існує близько 60 сигналів, але основні значення наступні:

Ім'я сигналу    Номер сигналу           Дія

SIGHUP                1               Відключити

SIGKILL               9                 "Вбити"

SIGTERM               15                Перервати


SIGTERM використовується за умовчанням. Це найбезпечніший спосіб переривання процесу, коли з додатком відправляється запит, який може бути оброблений або проігнорований.

SIGHUP - менш безпечний спосіб.

SIGKILL - найменш безпечний варіант, переривання процесу без збереження, цей сигнал не може бути проігнорований або перехоплений.

Ідентифікатори процесів:

Щоб перервати ( "kill") процес, нам потрібно знати його ідентифікатор (Process ID або PID). Він генерується автоматично при запуску кожної програми і є у кожного процесу в Linux. Перший процес, що запускається при завантаженні Linux - init, тому в більшості випадків йому присвоюється ідентифікатор '1'.

```Init``` - системний процес, його не можна перервати таким чином. При отриманні сигналу він сам вирішує, чи дозволити себе перервати, таким чином, команда kill стає просто запитом на відключення системи. Це зроблено для того, щоб виключити випадкове переривання системних процесів.

Важливо відмітити:

   Користувач може перервати будь-який свій процес.

   Користувач не може перервати процес іншого користувача.

   Суперкористувач (root) може перервати системний процес і процес будь-якого користувача.

   Користувач не може перервати системний процес

Для переривання процесу по імені, а не ідентифікатором, використовується команда pkill.

```pkill ім'я_процесу```

Якщо у процесу занадто багато екземплярів і дочірніх процесів, існує команда killall, якої в якості аргументу також задається ім'я процесу.

```killall [сигнал або опція] ім'я_процесу```


17. Commands jobs, fg, bg, nohup. What are they for? Use the sleep, yes command to demonstrate the process control mechanism with fg, bg.


Команди виконання процесів у фоновому режимі - jobs, fg, bg

Команда jobs виводить список процесів, які виконуються у фоновому режимі;

fg - переводить процес в нормальні режим ("на передній план" - foreground);

bg - переводить процес у фоновий.

Запустити програму у фоновому режимі можна за допомогою конструкції <команда> &. Наприклад в командному рядку напишемо таке:

```sleep 100 &```

Тепер перевіримо, чи виконується процес:

```jobs```



Виведемо процес sleep 100 & на передній план. Він у нас під номером 1, тому:

```fg% 1```

Зараз він не повинен відобразитися через команду jobs, тому що перестав бути фоновим. перевіримо:

Part2

1. Check the implementability of the most frequently used OPENSSH commands in the MS Windows operating system. (Description of the expected result of the commands + screenshots: command – result should be presented)

![image](https://user-images.githubusercontent.com/58170246/133927380-23fcc101-9bda-4318-96bf-4221f4022653.png)

Перекидання портів для SSH

![image](https://user-images.githubusercontent.com/58170246/133927457-cae5f93c-6387-49d6-a93e-9519a971f5ab.png)

![image](https://user-images.githubusercontent.com/58170246/133927605-8b12f1cf-3ccf-4a56-8794-5b9234413bee.png)

![image](https://user-images.githubusercontent.com/58170246/133927772-7522b849-d411-4916-ae4b-ecd8ae0efce3.png)

Аналогічним способом виконується підключення за допомогою PuTTY. В поле «Host Name» вказуємо «localhost», а в поле «Port» - «2222»

![image](https://user-images.githubusercontent.com/58170246/133927831-340c4917-463d-446e-8b59-1afa312814a3.png)

підключення через мережевий міст.

![image](https://user-images.githubusercontent.com/58170246/133928128-0d83e3ee-9ece-4453-a694-bb5bd278bc30.png)

![image](https://user-images.githubusercontent.com/58170246/133928299-259fce5a-aa9e-446a-9e5b-37b8af640dc2.png)

![image](https://user-images.githubusercontent.com/58170246/133928376-27bdbd3c-e93b-4d4c-a47d-2a1babadc90f.png)

![image](https://user-images.githubusercontent.com/58170246/133928474-32acd745-b055-48cd-9a38-e3d87ccf67bd.png)

![image](https://user-images.githubusercontent.com/58170246/133928492-7331e4b4-dfa8-4a5a-b48b-8a39986c52fb.png)



2. Implement basic SSH settings to increase the security of the client-server connection (at least https://netpoint-dc.com/blog/povishenie-bezopasnosti-ssh/ 

Основы SSH
SSH состоит из двух частей: сервер sshd, принимающий запросы на соединения от клиентов, и клиент ssh, который используется для соединения с сервером. Обычно администрирование сервера производится с использованием клиента SSH из системы, на которой вы работаете. В ОС семейства Windows часто используется клиентское программное обеспечение Putty.

Говоря о безопасности конфигурации SSH, наибольший интерес представляет серверная часть. Например, на уровне сервера решается, разрешаются или запрещаются вход с использованием пароля. Даже если у клиента некоторые опции установлены явно, окончательное решение принимает сервер. Файл конфигурации сервера находится в каталоге ```/etc/ssh/sshd_config```.

Настройки конфигурации клиента можно найти в ```/etc/ssh/ssh_config``` (на уровне системы) или в ```~/.ssh/config```(на уровне пользователя). Настройки также можно определить в процессе подключения посредством передачи параметра командной строки.

Прежде, чем вносить изменения, рассмотрим, как сделать это правильно.

Советы по установке
Не используйте «лучшие практики» без понимания сути
В сети много статей и инструкций, которые утверждают, что в них представлены лучшие практики. Лучшая практика — это эффективный и проверенный подход, часто согласованный с экспертами. К сожалению, многие блоги и статьи являются копией других блогов, и им не хватает глубоких исследований. Поэтому рекомендуем сначала изучить дополнительную информацию о блоге, который вы читаете, или его авторе.

Если в статье представлены только настройки конфигурации без четких объяснений, их стоит применять с осторожностью. Некоторые из них могут быть устаревшими, другие — некорректными. Зачем устанавливать значение, если оно уже установлено по умолчанию или удалено? Поэтому, чтобы вы ни делали, относитесь к этому критично и не делайте предположений. Используйте лучшие практики, но всегда проверяйте те изменения, которые вносите.

Проверка статуса SSH
Вы впервые редактируете конфигурации SSH? Тогда сначала проверьте статус SSH-демона и посмотрите, запущен ли нужный сервис при загрузке. При использовании дистрибутива, использующего systemd, убедитесь, что демон запущен и включен.

```systemctl status ssh.service```
На некоторых дистрибутивах Linux сервис называется sshd.service.

В ответе должно вернуться значение enabled:

Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)
Подтверждение, что SSH запущен, выглядит следующим образом:

Active: active (running) since Mon 2018-06-04 17:18:33 CEST; 1 months 2 days ago
Использование теста конфигурации SSH
При внесении изменений в конфигурацию SSH, целесообразно перезапустить сервис. Настоятельно рекомендуем перед запуском проверять конфигурацию (sshd_config). Это можно сделать используя флаг test mode. Этот дополнительный шаг позволяет убедиться, что синтаксис и опции корректны.

sudo sshd -t
Команда не должна возвращать текст или ошибки.

Внесение изменений в настройки SSHD удаленной системы
Сервер SSH не сбрасывает текущие открытые сессии при выполнении команд reload, restart.Никогда не закрывайте текущую рабочую сессию при внесении изменений в конфигурацию сервера SSH. Перезапустите сервис sshd, откройте дополнительную сессию и убедитесь, что соединение устанавливается. Если вы хотите «выбросить» текущих подключенных пользователей, вы должны послать kill всем процессам SSH.

Для систем c systemd используйтеsystemctl для перезагрузки сервиса SSH:

systemctl reload ssh.service
Так же возможно отправить сигнал SIGHUP родительскому процессу. Но не отправляйте сигнал дочерним процессам, иначе произойдет отключение.

kill -HUP 1234
Альтернативный способ — временно запустить другой процесс SSH на другом порту в интерактивном режиме. Укажите полный путь к исполняемому файлу sshd и флаги -D и -p для значения порта. Убедитесь, что доступно временное соединение, соединившись клиентом SSH с временным сервисом.

/usr/sbin/sshd -D -p 2222
Для остановки процесса используйте CTRL+C .

Перенастройка методом малых изменений
Часто имеет смысл задать новые настройки SSH сразу на всех системах, но иногда лучше перестраховаться. Например, некоторые старые клиенты SSH могут не поддерживать новые типы ключей. Чтобы иметь представление о возможных проблемах совместимости, проверьте SSH на самых старых используемых дистрибутивах Linux.

Активные соединения SSH
Перед применением изменений или перезапуском демона, проверьте активные SSH-соединения. Это можно сделать с помощью инструмента ss.

ss -n -o state established '( dport = :22 or sport = :22 )'
Вы увидите установленное соединение TCP. С помощью dport и sport можно проверить, какие соединения являются активными.

Улучшение безопасности сервера SSH
Подготовка
Прежде, чем вносить изменения в конфигурацию, создадим резервную копию.

cp /etc/ssh/sshd_{config,.config.orig}
На этом этапе полезно знать, что каждая версия OpenSSH имеет свои значения по умолчанию, где новая функциональность может добавиться, а старая удалиться. Чтобы узнать, задана ли специальная настройка, не полагайтесь на конфигурационный файл. Вместо этого вызовите демон SSH с флагом расширенного тестового режима -T, чтобы просмотреть полную информацию.

sshd -T
Ответ может выглядеть следующим образом (листинг приведен не полностью):

# sshd -T
port 2022
protocol 2
addressfamily any
listenaddress [::]:2022
listenaddress 0.0.0.0:2022
usepam yes
serverkeybits 1024
logingracetime 120
keyregenerationinterval 3600
x11displayoffset 10
maxauthtries 6
maxsessions 10
clientaliveinterval 0
clientalivecountmax 3
streamlocalbindmask 0177
permitrootlogin yes
ignorerhosts yes
ignoreuserknownhosts no
rhostsrsaauthentication no
....
Настройки конфигурации и значения отображаются в нижнем регистре.

Настройки безопасности SSH
Приведенные далее настройки позволяют значительно уменьшить вероятность взлома сервера с помощью SSH.

Использование нестандартного порта для сервера
Боты, сканирующие уязвимые учетные записи SSH ожидают его на порту 22. Если вы поменяете порт SSH на нестандартный, например, 3022, вы значительно снизите интенсивность сканирования и вероятность проникновения в систему даже при использовании нестойких паролей:

Port 3022 
Использование X11Forwarding
Если пересылка графического трафика X11 поверх SSH не требуется, отключите его:

X11Forwarding no
Почему важно отключать передачу X11: протокол X11 не предусматривает настроек безопасности. Открывая канал клиенту, сервер может отправлять ему вредоносные команды. Чтобы защитить клиента, отключите передачу X11, если она не нужна.

Отключение rhosts
Аутентификация с использованием rhosts чрезвычайно удобна в локальных сетях, где одни и те же пользователи имеют учетные записи на разных машинах. Однако следует внимательно следить за тем, чтобы такой тип аутентификации был запрещен на компьютерах, подключенных к сетям, в которых может реализовываться атака, основанная на подмене IP-адреса. Этот способ аутентификации сегодня не столь распространен, так как является небезопасным: основанием для доверия другой системе является только IP-адрес. По умолчанию использование rhosts отключено. Не забудьте проверить, так ли это в действительности.

IgnoreRhosts yes
Проверка имени хоста DNS
Сервер SSH может проверять, устанавливает соответствие доменного имени клиента его адресу с помощью DNS. Такая проверка может быть активирована следующим способом:

UseDNS yes
Данная опция не во всех случаях будет хорошо работать. В результате ее использования возникнет дополнительная задержка при установлении соединения, так как сервер SSH будет проверять имя клиента через DNS, а при невозможности резолвинга будет ожидать тайм-аута DNS. Используйте ее, только когда уверены в корректной настройке DNS.

Отключите пустые пароли
Аккаунты должны быть защищены, а пользователи — учтены. Поэтому использование пустых паролей следует запретить. Их можно отключить с помощью опции PermitEmptyPasswords, которая используется по умолчанию.

PermitEmptyPasswords no
Максимальное количество попыток аутентификации
Для защиты от атак на пароли пользователя ограничьте число попыток входа с помощью настройки MaxAuthTries.

MaxAuthTries 3
Также активируйте отслеживание ошибок аутентификации по достижении половины от максимального количества попыток. Используйте ошибки аутентификации вместе с программным обеспечением SIEM (например, Snort), или перенаправляйте их администратору безопасности.

Сервер SSH может быть настроен для использования PAM или подключаемых модулей аутентификации. Используя набор правил, являющихся частью стека аутентификации, можно использовать количество неудачных попыток входа в систему для блокировки конкретного пользователя. Другой вариант — определить период блокировки аккаунта по достижении установленного числа попыток. В этом случае сервер будет лучше защищен от прямого подбора паролей к аккаунту пользователя.

При ограничении количества попыток входа помните, что аутентификация по открытому ключу (см. ниже) также может входит в число попыток. Если нужно принудить SSH-клиент (или SCP) использовать аутентификацию при помощи пароля, используйте соответствующие опции:

```ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no username@system```
Аутентификация с помощью публичного ключа
Вместо стандартного доступа по паролю лучше использовать аутентификацию с помощью инфраструктуры публичных ключей. Ключи считаются более безопасным средством аутентификации и меньше подвержены атакам «грубой силы». Чтобы заставить пользователя использовать ключи, отключите PasswordAuthentication.

PubkeyAuthentication yes
PasswordAuthentication no
Больше информации об использовании ключей SSH вместо паролей для аутентификации вы найдете в статье.

Отключите вход для учетной записи root
Правильной практикой считается не использовать для входа в систему учетные данные пользователя root. Вместо этого используйте для инициации соединения непривилегированный аккаунт пользователя с правами sudo. Вход в систему под root-пользователем может привести к ошибкам в аудите действий, совершенных в аккаунте.

PermitRootLogin no
Более новые версии OpenSSH также поддерживают значение without-password. Это значение позволяет устанавливать соединение для учетной записи root только с использованием инфраструктуры публичных ключей.

Установите версию разрешенного протокола SSH
Если вы используете старую версию SSH, там может использоваться протокол версии 1. В этом протоколе есть ошибки, и его не стоит использовать. Начиная с OpenSSH версии 7.0 протокол версии 1 автоматически отключается при компиляции. Если вы используете раннюю версию SSH, установите версию протокола явно:

Protocol 2
Использование AllowUsers и DenyUsers
Если доступ к системе должен быть не у всех пользователей, ограничьте субъектов, имеющих к ней доступ. Один из способов — создать группу (например, sshusers) и добавить в нее пользователей. Затем определить параметр AllowGroups, чтобы разрешить доступ в систему только этим пользователям.

Другой способ — разрешить доступ пользователям с помощью настройки AllowUsers, или запретить доступ пользователям и группам пользователей с помощью DenyUsers или DenyGroups. Как правило, лучше использовать белые списки доступа совместно с политикой доступа «отказ по умолчанию». Поэтому при возможности применяйте настройки AllowUsers или AllowGroups.

Полезно помнить, что SSH проверяет списки пользователей для доспуска в систему в следующем порядке: DenyUsers, AllowUsers, DenyGroups и наконец AllowGroups.

Использование HashKnownHosts
Каждый раз, когда SSH-клиент подключается к серверу, он сохраняет соответствующую подпись (ключ) сервера. Эта информация хранится в файле known_hosts, доступный в поддиректории .ssh соответствующего пользователя (на клиенте). В случае, когда подпись сервера отличается, SSH уведомляет пользователя об этом, и подключение не устанавливается. Это полезная опция, но есть риск. Изначально обычной практикой считалось сохранять имя хоста, соответствующего конкретному ключу хоста. Это позволяло червям и другим вредоносным скриптам легко использовать данную информацию и после взлома одной системы передавать ее другим системам. Чтобы противостоять этому, используйте HashKnownHosts, который будет создавать хэши имён хостов из ~/.ssh/known_hosts. Использование хэшей имён хостов вместо самих имён хостов поддерживается в ssh(1) и sshd(8), и позволяет предотвратить утечку информации в случае разглашения содержимого файла. По умолчанию стоит значение no. Файл становится нечитабельным для человеческого глаза, но он по-прежнему позволяет SSH проверять ключ сервера при следующем подключении к той же системе.

Пример ответа:

|1|XV5CFMH8LLIQPq7PxdBhGX7I9PA=|VKNLdODsQlJ/j4cvTZncqs9vgh0= ecdsa-sha2-nistp256 AAAAE2VjZHNhLX….dJ/RzzZLH8Hs0UgroC0=
Запрет разрешенных для выполнения команд
OpenSSH позволяет запретить команды, которые можно запускать, с помощью опции command, расположенной в файле authorized_keys вместе с информацией о публичном ключе.

command="ps",no-agent-forwarding,no-port-forwarding,no-x11-forwarding, TYPE_OF_KEY KEY COMMENT
В примере выше замените поля TYPE_OF_KEY, KEY и COMMENT. Значения, которые должны использоваться, соответствуют тем, которые используются при аутентификации по открытому ключу.

Дополнительные ограничения
Настройка брандмауэра
Помимо внесения изменений в конфигурацию SSH, стоит ограничить доступ с помощью фильтрации трафика. Можно использовать локальный брандмауэр, например iptables или nftables, для ограничения доступа только c разрешенных систем. Ограничьте доступ, разрешив трафик только с доверенных IP-адресов.

Использование jump-сервера
Большие инфраструктуры как правило ограничивают доступ, используя jump-сервер или jump-хост, или узел-бастион. Они являются единственными системами в сети, конфигурации которых разрешают доступ к другим системам. Это означает, что, если необходимо администрировать систему, в первую очередь необходимо подключиться к jump-серверу, а оттуда — к целевой системе. Это отлично работает вместе с ограничением доступа посредством брандмауэра.

Настройки безопасности клиента OpenSSH
Доступно множество клиентов SSH, поэтому рассказать о каждом из них в одной статье невозможно. Остановимся подробнее на инструменте клиента OpenSSH.

Конфигурация клиента
Клиент OpenSSH можно настроить тремя способами. Они обрабатываются по порядку и проверяются для каждого доступного параметра конфигурации. Выбирается первый подходящий.

Настройки задаются через командную строку;
Через файл конфигурации в домашней директории (~/.ssh/config);
Через файл конфигурации для всех пользователей (/etc/ssh/ssh_config).
Допустим, есть настройка А. Она задана для всей системы (3 способ) со значением «True». Пользователь michael установил для нее значение «False» (2 способ). В этом случае второе значение в приоритете, т.к. оно рассматривается перед настройками всей системы.

Просмотр активных настроек
Помните, как мы просматривали настройки для сервера (sshd -T)? У клиента есть похожий инструмент.

```ssh -G abc```
Здесь abc является произвольным именем хоста. Или, возможно, не совсем произвольным. Можно использовать что угодно, включая реальное имя хоста. Клиент может использовать блоки Host и Match для настройки конфигурации группы систем или отдельной системы. Если хоста abc не существует, будут рассматриваться настройки по умолчанию.

Настройки SSH для отдельной системы
Допустим, есть система secureserver. Вместо того, чтобы работать на порте 22, она принимает соединения по SSH на порте 2222. Вместо применения -p в командной строке можно добавить блок Host в файл конфигурации. Для этого необходимо в каталоге .ssh домашней директории создать файл config (/home/username/.ssh/config).

Затем создадим блок и определим нужные настройки.

Host secureserver
    Hostname hostname.example.org
    User mynickname
    Port 2222
    MACs hmac-sha2-512
    KexAlgorithms curve25519-sha256@libssh.org
Отступы необязательны, но рекомендуются, чтобы отличать, какие настройки к какому хосту относятся.

Какие же настройки следует определять в файле конфигурации клиента?

Рекомендуем использовать те, которые облегчат вам ежедневную работу. Если вы отдаете предпочтение безопасности, задайте надежные настройки по умолчанию. Если какой-то хост использует другой SSH-порт, создайте блок Host и переопределите его настройки нужным образом. Что касается KexAlgorithms, используйте более новые доступные алгоритмы. Это сильно зависит от версии OpenSSH на серверах. Если на сервере используется новая версия OpenSSH, то хорошо подойдет curve25519. Это высокоскоростной алгоритм на основе эллиптических кривых, который на данный момент считается безопасным.

Инструменты для анализа безопасности SSH
Программные продукты и настройки со временем меняются. Поэтому полезно регулярно их сканировать.

Lynis
Универсальный инструмент безопасности с открытым кодом для тестирования безопасности систем Linux. Он проверит все, что может, от загрузчика до сервера. Он бесплатный и написан с помощью shell script. Lynis работает в самой системе, поэтому может просматривать как файлы конфигурации, так и фактически загруженную конфигурацию. Он включает в себя несколько тестов для OpenSSH и его конфигураций, включая параметры безопасности. Результаты или возможные улучшения отображаются на экране, что позволяет непосредственно приступить к действиям и начать усиливать безопасность системы.

Скачайте утилиту с GitHub или с сайта. Используйте инструкцию, чтобы быстрее понять, с чего начать работу.

```ssh-audit```
Несмотря на то, что инструмент ssh-audit немного устарел, его стоит иметь в своем арсенале. Вместо тестирования на самом хосте, он может подключаться к SSH-серверу через сеть. Он выполняет тестирование на выбранной системе и просматривает полученные ответы, на основании которых узнает о системе и сервере SSH. Он даже узнает о конкретных уязвимостях и может предупредить о них. Загрузите инструмент через GitHub и попробуйте применить.

Чтобы найти больше информации о других инструментах, читайте раздел «Сканеры конфигурации безопасности Linux».

Ресурсы
Справочная страница
Хорошим ресурсом о настройках конфигурации SSH является man-страница. Хотя это звучит как простой совет, на самом деле важно помнить, что справочная страница является полезной и актуальной. При всех незначительных различиях между релизами часто сложно догадаться самостоятельно, что делает настройка. Вместо этого лучше прочитать о настройке и посмотреть, есть ли в ней изменения. Объедините эти знания с выводом команды sshd -T, и это позволит выбрать максимально правильный вариант для вашей конкретной ситуации.


3. List the options for choosing keys for encryption in SSH. Implement 3 of them.

4. Implement port forwarding for the SSH client from the host machine to the guest Linux virtual machine behind NAT.

5*. Intercept (capture) traffic (tcpdump, wireshark) while authorizing the remote client on the server using ssh, telnet, rlogin. Analyze the result. 

![image](https://user-images.githubusercontent.com/58170246/133930276-1c3eac28-7236-4b97-9bed-42c2c7ea2dad.png)

```tcpdump [options] [expression]```

Команда ```options``` позволяют вам контролировать поведение команды.

Фильтр ```expression``` определяет какие пакеты будут захвачены

Для початку використовуйте команду ```tcpdump -D```, щоб побачити, які інтерфейси доступні для захоплення:

![image](https://user-images.githubusercontent.com/58170246/133930354-8b73f0a2-2bde-4449-9fa4-910b2be8b67b.png)

Спеціальний інтерфейс ```any``` дозволяє захоплювати на всіх активних інтерфейсах.

![image](https://user-images.githubusercontent.com/58170246/133930411-7b094f5b-4a7a-46a0-80d1-807c65ae4142.png)

Ключ ```-i``` показує що ми захоплюємо пакети з певного (хоч і псевдо) інтерфейсу. Ви можете перервати захоплення, натиснувши ```Ctrl + C```.

![image](https://user-images.githubusercontent.com/58170246/133930473-42c383ea-c4f6-4d65-90d7-5c5112df062d.png)

перехоплено коло 64 пакетів

Але так багато чого нам не потрібно Щоб заборонити кількість перехоплених пакетів та припинити tcpdump, використовуйте параметр ```-c```:

![image](https://user-images.githubusercontent.com/58170246/133930571-44ebe01d-e8c3-4553-b1c0-f39b11bdf711.png)

За замовчуванням tcpdump використовує (переадресовує) IP-адресу та порти в імені, як показано у попередньому прикладі. Однак при усуненні неполадок у мережах частіше використовують IP-адреси та номери портів. Вимкніть дозволи імена, використовуючи опцію -n та дозволи портів з -nn:

![image](https://user-images.githubusercontent.com/58170246/133930712-9db64b00-48bb-447b-a1e8-f67b42b07b5a.png)

[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]

Первое поле, 08:41:13.729687, представляет метку времени полученного пакета согласно местным часам, в форматечасы:минуты:секунды.фракция где фракция - доли секунды с полуночи.
Затем IP представляет протокол сетевого уровня - в данном случае IPv4. Для пакетов IPv6 это значение IP6.
Следующее поле, 192.168.64.28.22, - это IP-адрес и порт источника. Далее следуют IP-адрес и порт назначения (разделенные точкой), представленные как 192.168.64.1.41916.
После источника и назначения вы можете найти флаги TCP Flags [P.]. Типичные значения для этого поля включают в себя:
[.] - ACK (Acknowledgment)
[S] - SYN (Start Connection)
[P] - PSH (Push Data)
[F] - FIN (Finish Connection)
[R] - RST (Reset Connection)
[S.] - SYN-ACK (SynAcK Packet)
Далее идет порядковый номер данных, содержащихся в пакете. Для первого захваченного пакета это абсолютное число. Последующие пакеты используют относительное число, чтобы упростить отслеживание. В этом примере последовательность seq 196:568, что означает, что этот пакет содержит байты с 196 по 568 этого потока.
За этим следует номер подтверждения: ack 1. В данном случае это 1, поскольку сторона отправляет данные. Для стороны, получающей данные, это поле представляет следующий ожидаемый байт (данные) в этом потоке. Например, номер Ack для следующего пакета в этом потоке будет 568.
Следующее поле - это размер окна win 309, который представляет количество байтов, доступных в приемном буфере, за которыми следуют такие параметры TCP, как MSS (максимальный размер сегмента - Maximum Segment Size) или масштаб окна. nop - заполнение, используемое для того, чтобы сделать заголовок TCP кратным 4 байтам. TS val - это временная метка TCP. ecr - обозначает эхо-ответ.
Наконец, у нас есть длина пакета, length 372, которая представляет длину в байтах данных полезной нагрузки. Длина - это разница между последним и первым байтами порядкового номера.

Для фільтрації пакетів на основі протоколу, вказав протокол в командній строці. Наприклад, перехватуйте пакети ICMP тільки за допомогою цієї команди:
```sudo tcpdump -i any -c5 icmp```

![image](https://user-images.githubusercontent.com/58170246/133930916-c311648d-04db-42c0-a6e7-b77b0e5509d0.png)


Щоб обмежити лише пакети, які стосуються відповідного хосту, використовуючи фільтр ```host```

Також можна фільтрувати не тільки по одному хосту, але і цілими підмережам. Для цього потрібно використовувати фільтр ```net```. Наприклад, щоб вивести тільки пакети, що відносяться тільки до ```192.168.1.0/24```, потрібно використовувати:

```sudo tcpdump -n net 192.168.1```


ПОРТ
Для фільтрації пакетів на основі бажаної послуги або порту використовуйте фільтр port. Наприклад, перехопити пакунки пов'язані з веб-службі HTTP c 80 порту, за допомогою цієї команди:

```sudo tcpdump -i any -c5 -nn port 80```
Щоб захоплювати трафік з діапазону портів використовуйте фільтр portrange, після якого через дефіс вкажіть бажаний діапазон:

```sudo tcpdump -n portrange 11128-11142```

Ви також можете фільтрувати пакети на основі IP-адреси джерела або призначення або назву за допомогою фільтра src, після якого потрібно вказати адресу відправника. Наприклад, для захоплення пакетів з хоста 192.168.122.98:

```sudo tcpdump -i any -c5 -nn src 192.168.122.98```
Зверніть увагу, що tcpdump захоплює пакети з вихідним IP-адресою 192.168.122.98 для декількох служб, таких як дозвіл імен (порт 53) і HTTP (порт 80). Пакети відповідей не відображаються, так як їх вихідний IP адреса у них відрізняється.

І навпаки, ви можете використовувати фільтр dst для фільтрації по IP-адресою або назву:

```sudo tcpdump -i any -c5 -nn dst 192.168.122.98```

СКЛАДНІ ВИРАЗИ
Ви також можете комбінувати фільтри за допомогою логічних операторів ```and```, ```or``` і ```not``` для створення більш складних виразів. Наприклад, щоб відфільтрувати пакети з IP-адреси джерела 192.168.122.98 і тільки службового HTTP, використовуйте цю команду:

```sudo tcpdump -i any -c5 -nn src 192.168.122.98 and port 80```


Ви можете створювати більш складні вирази, групуючи фільтр з круглими дужками. В цьому випадку укладете все вираз фільтра в лапки, щоб оболонка не переплутала їх з виразами оболонки:

```sudo tcpdump -i any -c5 -nn "port 80 and (src 192.168.122.98 or src 54.204.39.132)"```
У цьому прикладі ми фільтруємо пакети тільки для служби HTTP (порт 80) і вихідних IP-адрес 192.168.122.98 або 54.204.39.132. Це швидкий спосіб вивчення обох сторін одного і того ж потоку.

ПЕРЕВІРКА ЗМІСТУ ПАКЕТУ
У попередніх прикладах ми перевіряли тільки заголовки пакетів на наявність інформації, такої як джерело, адресати, порти і так далі. Іноді це все, що нам потрібно для усунення проблему підключення до мережі. Однак іноді нам необхідно перевірити вміст пакета, щоб переконатися, що в отправляемом повідомленні міститься те, що нам потрібно, або що ми отримали очікувану відповідь. Щоб побачити вміст пакету, tcpdump надає два додаткових прапора: -x для друку вмісту в шістнадцятковому форматі (HEX) і -A для друку вмісту в ASCII.

Наприклад, перевірте HTTP-вміст веб-запиту наступним чином:

```sudo tcpdump -i any -c10 -nn -A port 80```

ЗБЕРЕЖЕННЯ ФАЙЛУ
Інша корисна функція, яку надає tcpdump, - це можливість зберігати захоплення в файл, щоб ви могли проаналізувати результати пізніше. Це дозволяє вам захоплювати пакети в пакетному режимі, наприклад, вночі і перевіряти результати вранці. Це також допомагає, коли занадто багато пакетів для аналізу, оскільки захоплення в реальному часі може відбуватися дуже швидко.

Щоб зберегти пакети в файл, а не відображати їх на екрані, використовуйте параметр -w:

```sudo tcpdump -i any -c10 -nn -w webserver.pcap port 80```

Ця команда зберігає вихідні дані у файлі з ім'ям webserver.pcap. Розширення .pcap розшифровується як «packet capture» і є угодою для цього формату файлу.

Як показано в цьому прикладі, на екрані нічого не відображається, і захоплення завершується після захоплення 10 пакетів, згідно з опцією -c10. Якщо ви хочете отримати зворотній зв'язок, щоб гарантувати захоплення пакетів, використовуйте опцію -v.

Tcpdump створює файл в двійковому форматі, тому ви не можете просто відкрити його в текстовому редакторі. Щоб прочитати вміст файлу, виконайте tcpdump з опцією -r:

```tcpdump -nn -r webserver.pcap```

Інтерфейс командного рядка tcpdump забезпечує більшу гнучкість для захоплення і аналізу мережевого трафіку. Якщо вам потрібен графічний інструмент для розуміння більш складних потоків, подивіться на Wireshark.

Одним з переваг Wireshark є те, що він може читати файли .pcap, захоплені tcpdump. Ви можете використовувати tcpdump для захоплення пакетів на віддаленій машині, у якій немає графічного інтерфейсу користувача, і проаналізувати файл результатів за допомогою Wireshark.

