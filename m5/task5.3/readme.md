TASK 5.3 

Part1

1. How many states could has a process in Linux?


Процес - це:

1) програма на стадії виконання

2) "об'єкт", яким виділено процесорний час

3) асинхронна робота

У Linux існують два основних типи процесів:

• Процеси переднього плану (Foreground) - ці процеси не започатковано і контролюються на протязі кінцевої сесії. Іншими словами, повинен бути користувач, підключений до системи для запуску таких процесів; вони не запускалися автоматично як частина функцій / служб системи.

• Фонові процеси (Background) (також належні до неінтерактивному / автоматичним процесам) - це процеси, не пов'язані з терміналом; вони не очікують від користувача введення.

На скріншоті нижче зображена модель п'яти станів

![image](https://user-images.githubusercontent.com/58170246/133625011-48651e0a-f061-4ede-8099-38053d06de84.png)


2. Examine the pstree command. Make output (highlight) the chain (ancestors) of the current process.

У простій формі, коли викликається ```pstree``` без будь-якої опції або аргументу, вона відображає ієрархічну деревоподібну структуру всіх запущених процесів:

![image](https://user-images.githubusercontent.com/58170246/133625496-650bd6f0-462f-4b06-b1ae-9530a5fde48a.png)


3. What is a proc file system?


Linux надає ядру і модулям ядра додатковий механізм передачі інформації зацікавленим в ній процесам - це файлова система /proc. Спочатку вона створювалася з метою отримання відомостей про процеси (звідси така назва). Тепер вона інтенсивно використовується і самим ядром, якому є що повідомити!

Наприклад, /proc/modules - список завантажених модулів, /proc/meminfo - статистика використання пам'яті.

Методика роботи з файловою системою / proc дуже схожа на роботу драйверів з файлами пристроїв: ви створюєте структуру з усією необхідною інформацією, включаючи покажчики на функції-обробники (в нашому випадку є тільки один обробник, який обслуговує читання файлу в / proc).

Файлова система / proc була написана, головним чином, для того щоб отримувати дані від ядра, вона не передбачає спеціальних засобів для запису даних в файли. Файлова система / proc, всякий раз, коли ми реєструємо новий файл, дозволяє вказати - яка struct inode_operations буде використовуватися для доступу до нього. У свою чергу, в цій структурі є покажчик struct file_operations, а в ній вже знаходяться покажчики на наші функції-обробники.

Наша файлова система показана на скрині нижче.


![image](https://user-images.githubusercontent.com/58170246/133625973-020822dd-a011-4307-a7ed-51b11b3f94b9.png)

https://losst.ru/fajlovaya-sistema-proc-v-linux

4. Print information about the processor (its type, supported technologies, etc.).

```cat /proc/cpuinfo```


![image](https://user-images.githubusercontent.com/58170246/133626280-8d1781f3-ee3b-4849-8c4a-c0e920c5342f.png)

5. Use the ps command to get information about the process. The information should be as follows: the owner of the process, the arguments with which the process was launched for execution, the group owner of this process, etc. 

Команда ```ps``` за замовчуванням є у всіх дистрибутивах Linux. Без будь-яких аргументів і опцій ps показує запущені процеси, що виконуються користувачем у вікні терміналу:

![image](https://user-images.githubusercontent.com/58170246/133626566-d2ae3786-b6c9-4fe8-8e6f-770ca5923558.png)


На виході будуть відображатися рядка даних, що містять наступну інформацію: * PID - це унікальний ідентифікатор процесу;

TTY - тип терміналу;

TIME - це загальний час використання процесорного часу процесом (00:00:00 навпаки процесу bash вказує, що процесорний час взагалі не було використано до сих пір);

CMD - це ім'я команди, яка запустила цей процес.

Щоб отримати повний список, виконаємо наступну команду:
```ps -ef```

Опція -e, показує всі процеси, а -f показує повну інформацію:

UID - ідентифікатор користувача виконує команду;

PID - це ідентифікатор процесу команди;

PPID - ідентифікатор батьківського процесу, який відпустив команду;

C - кількість дочірніх процесів;

STIME - це час початку процесу;

TTY;

TIME;

CMD.

```ps -ef```

![image](https://user-images.githubusercontent.com/58170246/133626758-c034117b-a934-400b-b341-82de6466f177.png)

```ps aux```

6. How to define kernel processes and user processes?


```ps aux```

![image](https://user-images.githubusercontent.com/58170246/133760630-bd6cfec2-aff9-4af2-a47c-bc8a56248dd2.png)



Некоторые процессы указаны в квадратных скобках [ ] – это процессы, которые входят непосредственно в состав ядра и выполняют важные системные задачи, например, такие как управление буферным кэшем [pdflush] и организацией свопинга [kswapd].

Остальная часть процессов относится к пользовательским.



7. Print the list of processes to the terminal. Briefly describe the statuses of the processes. What condition are they in, or can they be arriving in?


Посмотрим список процессов:

```ps aux```


![image](https://user-images.githubusercontent.com/58170246/133760921-b3d71265-ac2d-41af-a832-34f9be46e8ef.png)



У таблиці відображається різна інформація про процес. Нас зараз цікавлять колонки PID (ідентифікатор процесу), USER (користувач, який запустив процес), STAT (стан процесу) і COMMAND (команда, яка була введена для запуску процесу).

Колонка STAT (стан процесу) може містити такі значення:

R: процес виконується в даний момент

S: процес очікує (тобто спить менше 20 секунд)

I: процес не діє (тобто спить більше 20 секунд)

D: процес очікує введення-виведення (або іншого недовгого події), неперервні

Z: zombie або defunct процес, тобто завершився процес, код повернення якого поки не прочитано батьком

T: процес зупинений

W: процес в своп

<: Процес в пріоритетному режимі.

N: процес в режимі низького пріоритету

L: real-time процес, є сторінки, заблоковані в пам'яті.

s: лідер сесії
 

8. Display only the processes of a specific user. 

```ps -fu iryna```

![image](https://user-images.githubusercontent.com/58170246/133761124-ac49cf84-bde8-41e2-be74-01a3cdde46d5.png)


```ps -al -u iryna```

![image](https://user-images.githubusercontent.com/58170246/133761279-66c76f62-a2d9-405f-87a6-babf75a2292d.png)



9. What utilities can be used to analyze existing running tasks (by analyzing the help for the ps command)?

УТИЛІТИ:

```ps```

```top```

![image](https://user-images.githubusercontent.com/58170246/133762079-4408b57b-56c2-43d5-9fc1-883caa93aa20.png)


```sudo apt-get install htop```

![image](https://user-images.githubusercontent.com/58170246/133762588-aadd2837-8246-4c6b-b5e4-d425357d129e.png)



```htop```

![image](https://user-images.githubusercontent.com/58170246/133762693-411662ff-c50d-4906-80cf-73ad9fce73dc.png)


```sudo apt-get install atop```

![image](https://user-images.githubusercontent.com/58170246/133762922-c3866b5b-97cb-4d3e-a78b-88eb051c4503.png)


```atop```


![image](https://user-images.githubusercontent.com/58170246/133762989-549a4dcf-b0d9-404a-b963-c7256300eb69.png)




10. What information does ```top``` command display?

Основні опції:

-v - вивести версію програми;

-b - режим тільки для виведення даних, програма не сприймає інтерактивних команд і виконується поки не буде завершена вручну;

-c - відображати повний шлях до виконуваних файлів команд;

-d - інтервал оновлення інформації;

-H - включає висновок потоків процесів;

-i - не відображати процеси, які не використовують ресурси процесора;

-n - кількість циклів оновлення даних, після яких треба закрити програму;

-o - поле, по якому треба виконувати сортування;

-O - вивести всі доступні поля для сортування;

-p - відстежувати тільки зазначені по PID процеси, можна вказати кілька PID;

-u - виводити тільки процеси, запущені від імені зазначеного користувача.

```top```

![image](https://user-images.githubusercontent.com/58170246/133763114-d00d3de4-1ef4-4bab-b659-807bd7036cdb.png)



Вікно можна умовно розділити на дві частини. У верхній частині знаходиться інформація про систему, спільне використання ресурсів процесора і пам'яті, розділу підкачки, і так далі. У нижній частині вікна розташований список запущених процесів з інформацією, відсортованих за певним полю.

Якщо всі процеси не поміщаються на одному екрані, їх можна гортати за допомогою стрілок вгору і вниз. Якщо не поміщаються всі колонки - за допомогою стрілок вправо і вліво:

11.Display the processes of the specific user using the ```top``` command..

Відобразимо процеси користувача iryna:

top -u iryna

![image](https://user-images.githubusercontent.com/58170246/133763244-6ca90e1a-f548-430c-bd0b-1dba7f70b48d.png)


12. What interactive commands can be used to control the top command? Give a couple of examples.

Розглянемо інтерактивні команди, які можна виконувати під час роботи програми:

h - висновок довідки по утиліті;

q або Esc - вихід з top;

A - вибір колірної схеми;

d або s - змінити інтервал оновлення інформації;

H - виводити потоки процесів;

k - послати сигнал завершення процесу;

W - записати поточні настройки програми в конфігураційний файл;

Y - подивитися додаткові відомості про процес, відкриті файли, порти, логи і т. Д;

Z - змінити колірну схему;

l - приховати або вивести інформацію про середньому навантаженні на систему;

m - вимкнути або переключити режим відображення інформації про пам'ять;

x - виділяти жирним колонку, по якій виконується сортування;

y - виділяти жирним процеси, які виконуються в даний момент;

z - перемикання між кольоровим і одноколірним режимами;

c - перемикання режиму виведення команди, доступний повний шлях і тільки команда;

F - настройка полів з інформацією про процеси;

o - фільтрація процесів за довільним умові;

u - фільтрація процесів на ім'я користувача;

V - відображення процесів у вигляді дерева;

i - щоб переключатися між процесів, які зараз не використовують ресурси процесора;

n - максимальна кількість процесів, для відображення в програмі;

L - пошук по слову;

<> - переміщення поля сортування вправо і вліво;

13. Sort the contents of the processes window using various parameters (for example, the amount of processor time taken up, etc.)

Shift + M - сортування за використанням пам'яті

![image](https://user-images.githubusercontent.com/58170246/133763870-a6c5e424-96f5-4ece-a5bc-827f2a6c0a9d.png)

Shift + T - за робочим часом

![image](https://user-images.githubusercontent.com/58170246/133764039-5ae71461-a2c8-4db3-b997-c5928842d3da.png)

Shift + N - за PID

![image](https://user-images.githubusercontent.com/58170246/133764116-3b947583-5e59-4bb3-93fa-11589f9f7f1d.png)

14. Concept of priority, what commands are used to set priority?

Кожному процесу в системі призначений певний пріоритет, який враховується планувальником процесів при виділенні процесу процесорного часу. Значення пріоритету знаходиться в діапазоні від -20 (найвищий пріоритет) до 19 (найменший: процес виконується тільки тоді, коли немає інших претендентів на час процесора). Значення, зворотне пріоритету, називається показником поступливості (nice).

За замовчуванням всі процеси запускаються з базовим пріоритетом, рівним 0. Власник процесу може в будь-який момент підвищити його показник поступливості (знизити пріоритет). Суперкористувач має право встановити для будь-якого процесу будь-яке значення пріоритету.

Якщо процес від'їдає занадто багато ресурсів, то для нормального функціонування системи не обов'язково його вбивати: досить призначити йому низький пріоритет. Тоді планувальник надасть йому менше циклів процесора, і його виконання займе більше часу, зате протягом цього часу можна буде виконувати інші завдання.

Для запуску процесу з пріоритетом, відмінним від базового, служить команда nice:

```nice [-n <пріоритет>] [командна_стрічка]```

Щоб змінити пріоритет вже запущеного процесу служить команда renice:

```renice -n <показник_поступливості> [-p PID] [-u UID]```

![image](https://user-images.githubusercontent.com/58170246/133764716-8bc71bbe-2d10-47bc-9c00-7a59cb8c62ee.png)



15. Can I change the priority of a process using the top command? If so, how?

Можна використовувати команду ```r``` під час виконання утиліти top, щоб змінити пріоритет поточного запущеного процесу.

16. Examine the kill command. How to send with the kill commandprocess control signal? Give an example of commonly used signals.


Використання команди ```kill```  з /usr/bin надає додаткову можливість перервати процес по його імені за допомогою ```pkill```. Стандартний синтаксис команди kill наступний:

```kill [сигнал або опція] ідентифікатор(и) процесу(ів)```

Для команди kill існує близько 60 сигналів, але основні значення наступні:

Ім'я сигналу    Номер сигналу           Дія

SIGHUP                1               Відключити

SIGKILL               9                 "Вбити"

SIGTERM               15                Перервати


SIGTERM використовується за умовчанням. Це найбезпечніший спосіб переривання процесу, коли з додатком відправляється запит, який може бути оброблений або проігнорований.

SIGHUP - менш безпечний спосіб.

SIGKILL - найменш безпечний варіант, переривання процесу без збереження, цей сигнал не може бути проігнорований або перехоплений.

Ідентифікатори процесів:

Щоб перервати ( "kill") процес, нам потрібно знати його ідентифікатор (Process ID або PID). Він генерується автоматично при запуску кожної програми і є у кожного процесу в Linux. Перший процес, що запускається при завантаженні Linux - init, тому в більшості випадків йому присвоюється ідентифікатор '1'.

```Init``` - системний процес, його не можна перервати таким чином. При отриманні сигналу він сам вирішує, чи дозволити себе перервати, таким чином, команда kill стає просто запитом на відключення системи. Це зроблено для того, щоб виключити випадкове переривання системних процесів.

Важливо відмітити:

   Користувач може перервати будь-який свій процес.

   Користувач не може перервати процес іншого користувача.

   Суперкористувач (root) може перервати системний процес і процес будь-якого користувача.

   Користувач не може перервати системний процес

Для переривання процесу по імені, а не ідентифікатором, використовується команда pkill.

```pkill ім'я_процесу```

Якщо у процесу занадто багато екземплярів і дочірніх процесів, існує команда killall, якої в якості аргументу також задається ім'я процесу.

```killall [сигнал або опція] ім'я_процесу```


17. Commands jobs, fg, bg, nohup. What are they for? Use the sleep, yes command to demonstrate the process control mechanism with fg, bg.


Команди виконання процесів у фоновому режимі - jobs, fg, bg

Команда jobs виводить список процесів, які виконуються у фоновому режимі;

fg - переводить процес в нормальні режим ("на передній план" - foreground);

bg - переводить процес у фоновий.

Запустити програму у фоновому режимі можна за допомогою конструкції <команда> &. Наприклад в командному рядку напишемо таке:

```sleep 100 &```

Тепер перевіримо, чи виконується процес:

```jobs```



Виведемо процес sleep 100 & на передній план. Він у нас під номером 1, тому:

```fg% 1```

Зараз він не повинен відобразитися через команду jobs, тому що перестав бути фоновим. перевіримо:

Part2

1. Check the implementability of the most frequently used OPENSSH commands in the MS Windows operating system. (Description of the expected result of the commands + screenshots: command – result should be presented)

2. Implement basic SSH settings to increase the security of the client-server connection (at least 

3. List the options for choosing keys for encryption in SSH. Implement 3 of them.

4. Implement port forwarding for the SSH client from the host machine to the guest Linux virtual machine behind NAT.

5*. Intercept (capture) traffic (tcpdump, wireshark) while authorizing the remote client on the server using ssh, telnet, rlogin. Analyze the result. 
